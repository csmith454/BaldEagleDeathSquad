Bald Eagle Death Squad presents: The Hive

Daniel - I worked on the player character, as well as helped with bug fixing and finalizing a lot of systems. I implemented 9 unique different abilities for the player which all presented unique challenges, with the full list of abilities being: sword, spike trap, bow, sprint/dash, slowness field, flip, rocket launcher, box placement, and wind machine (we named it fus-roh-dah in game). Each ability works differently and there's even some fun niche interactions with a few of them, try pushing the zombies into the water on the third level with the wind machine! I implemented multiple different classes, from simple ones dealing with projectiles and particles like arrows and dust, as well as classes representing player states such as a movement state, a dash state, and a hitstun state. I also implemented the camera class to allow for the player to explore a world that exists offscreen, which was a lot easier than I expected it to be. There's also the stateMachine itself, which is a modified version of some code I got from this tutorial: https://game.courses/bots-ai-statemachines/ which I rewrote to work with java. Some of the work I did for finalizing systems included adding knock back and damage indicators to both the player and the zombies, implementing some timer buffers so that UI elements can't be accidentally clicked too fast, and adding niche interactions with the zombies and abilities among other things. Finally I was in charge of most of the collisions in the game, which was more challenging than I first thought it would be. There's some instances where some collisions might not work as intended (such as zombies that move especially fast going through walls/over water) but most of the collisions are sound.

Asas - I worked on the zombie behavior, horde mechanics, evolution simulation and all the sound effects present in-game, including the music tracks. I implemented zombies which evolve based on how the player plays against them. Each individual zombie has genes like vision, size, damage, etc. and these genes are linked and change related to one another. This creates genetic diversity which allows the zombie horde to achieve differential success in terms of how much damage they can do to the player. Those zombies that deal the most damage to the player are then rewarded by score, which informs the basis for the next level's zombie population in terms of genes. The zombie horde progressively gets more difficult to play against. Another thing I did was I utilized the minim library to implement background music tracks and an audio track that plays from the zombies. This was done to add ambience to the game. I encountered a lot of roadblocks when I was working with audio, and I wish I had more time to implement more audio files in various places in the game such as for weapons and the player's abilities. That would have really rounded out the audio segment much better. I also wanted to introduce more levels with more diverse enemies that have their own seperate genes, as that would have made the evolution simulation aspect of the game more obvious.

Cole - I worked on the level generation from JSON files (encapsulated in the Level and Tiles classes).  Apart of this was the creation of many unique, seamless tiles that cultivate the space.  Using Tiled, I was able to provide lists of collision and spawn objects with certain characteristics that allow for complex interaction between the map and various entities.  I also created the GUI class, which includes handling for the main screen, in-game HUD, power-up select screens, the death, and the win screen.  Utilizing game states, it was relatively straight forward to craft the navigation between levels, but I found it more challenging to handle the various interactions and/or checks that needed to be addressed in order to meet the requirements of progression.  To make progression fluid, I used a Button and RectButton class with button animation to provide more interactivity and agency for the player. I also created the HighScore class that allows for data input and output that is saved between instances of the game. I really enjoyed helping create this project, and I think the final product is a genuinely fun and developed game.
